---
title: 'Preprocessing_LJ'
author: 'Maud Van Ginneken'
output:
  pdf_document:
    number_sections: yes
    keep_tex: yes
  html_document:
    df_print: paged
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache = TRUE, autodep = TRUE, warning = FALSE, 
                      message = FALSE, echo = FALSE, eval = TRUE, tidy = TRUE,
                      fig.width = 6, fig.height = 3.5, purl = TRUE, 
                      fig.show = "hold", fig.pos = "p")
```

```{r}
#library("SingleCellExperiment")
library("Seurat")
library("tidyverse")
#library("rgl")
#library("car")
#library("gridExtra")
library("pheatmap")
library("tibble")
#library("reshape2")
library("dplyr")
```
\tableofcontents

# Introduction

We will use the Seurat 'ecosystem' in R for our preprocessing workflow:

We create a Seurat object from a count matrix (a big matrix storing all RNA transcript counts for every cell). The object serves as a container that contains both data (like the count matrix) and analysis results (like PCA or clustering results) for a single-cell dataset. See: https://satijalab.org/seurat/articles/pbmc3k_tutorial.html

Ref: similar workflow (on the same dataset) in Python using Scanpy: https://training.galaxyproject.org/training-material/topics/single-cell/tutorials/scrna-plant/tutorial.html

# Data

```{r}
set.seed(1679)
```

# Load OrthoFinder orthologues and orthogroups 

```{r}
# Orthologues from OrthoFinder results 
AT_LJ <- read.table(file = '/scratch/gent/472/vsc47291/MA1_CompPlantDev/data/Proteomes/primary_transcripts/OrthoFinder/Results_Mar05/Orthologues/Orthologues_Arabidopsis_thaliana/Arabidopsis_thaliana__v__Lotus_japonicus.tsv', sep = '\t', header = TRUE)

# Extract one-on-one orthologues 
AT_LJ_Orthologues <- subset(AT_LJ, !grepl(",", Arabidopsis_thaliana) & !grepl(",", Lotus_japonicus), select = -Orthogroup)
```

```{r}
# Orthogroups from OrthoFinder results 
AT_LJ_Orthogroups <- read.csv('/scratch/gent/472/vsc47291/MA1_CompPlantDev/data/AT_LJ_Orthogroups.csv', header = TRUE)
```

```{r}
# Compare two dataframes 
# (check)
AT_LJ_Common <- inner_join(AT_LJ_Orthogroups, AT_LJ_Orthologues)
```

```{r}
#Load dataset
LJ_root <- readRDS("/scratch/gent/472/vsc47291/MA1_CompPlantDev/data/Frank2023/frank2023_counts.rds") 

obj.list <- SplitObject(LJ_root, split.by = "Condition")

# Create vector in which LJ gene names are replaced by AT orthologues 
ljcounts <- obj.list[["Control"]]@assays[["RNA"]]@counts@Dimnames[[1]]

ortho_names <- replace(ljcounts, which(ljcounts %in% AT_LJ_Orthogroups$Lotus_japonicus), AT_LJ_Orthogroups$Arabidopsis_thaliana[AT_LJ_Orthogroups$Lotus_japonicus %in% ljcounts])

# Replace Seurat gene name vectors by new vector containing AT orthologous gene names
obj.list[["Control"]]@assays[["RNA"]]@counts@Dimnames[[1]] = ortho_names
obj.list[["Control"]]@assays[["RNA"]]@data@Dimnames[[1]] = ortho_names
rownames(obj.list[["Control"]]@assays[["RNA"]]@meta.features) = ortho_names

LJ_root <- CreateSeuratObject(counts = obj.list[["Control"]]@assays[["RNA"]], project = "LJ_root")
```

# QC metrics, data normalization, scaling, feature selection

```{r}
LJ_root[["percent.mt"]] <- PercentageFeatureSet(LJ_root, pattern = "^LotjaGiM")
LJ_root[["percent.clp"]] <- PercentageFeatureSet(LJ_root, pattern = "^LotjaGiC")


# Visualize QC metrics as a violin plot
VlnPlot(LJ_root, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.clp"), ncol = 4)
```

```{r}
plot1 <- FeatureScatter(LJ_root, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(LJ_root, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot3 <- FeatureScatter(LJ_root, feature1 = "nCount_RNA", feature2 = "percent.clp")
plot1 + plot2 + plot3
```

# Dimension reduction

```{r}
# Histogram before normalization 
hist(colSums(LJ_root@assays$RNA),
     breaks = 100,
     main = "Library size before normalisation",
     xlab = "Library size")

```

```{r}
# Data normalization
#LJ_root <- NormalizeData(LJ_root)
```

```{r}
# Histogram after normalization 
#hist(colSums(LJ_root@assays$RNA),
#     breaks = 100,
#     main = "Library size after normalisation",
#     xlab = "Library size")

```

```{r fig.width=8}
# Select 5000 most variable features 
LJ_root <- FindVariableFeatures(LJ_root, selection.method = "vst", nfeatures = 5000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(LJ_root), 10)

# Plot variable features with and without labels
plot1 <- VariableFeaturePlot(LJ_root)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```

```{r}
# Scaling the data 
all_genes <- rownames(LJ_root)
LJ_root <- ScaleData(LJ_root, features = all_genes)
```

```{r fig.height = 6}
# Linear dimensional reduction
LJ_root <- RunPCA(LJ_root, npcs = 100, features = VariableFeatures(object = LJ_root))

# Examine and visualize PCA results a few different ways
print(LJ_root[["pca"]], dims = 1:5, nfeatures = 5)

# Visualize loadings
VizDimLoadings(LJ_root, dims = 1:2, reduction = "pca")
```

```{r}
DimPlot(LJ_root, reduction = "pca", cols = "black") + NoLegend()
```

```{r}
# Elbow plot
ElbowPlot(LJ_root, ndims = 100)
```

```{r}
LJ_root <- RunUMAP(LJ_root, dims = 1:10, reduction.name = "umap10")
DimPlot(LJ_root, reduction = "umap10", cols = "black")
```

```{r}
LJ_root <- RunUMAP(LJ_root, dims = 1:30, reduction.name = "umap30")
DimPlot(LJ_root, reduction = "umap30", cols = "black")
```

```{r}
LJ_root <- RunUMAP(LJ_root, dims = 1:60, reduction.name = "umap60")
DimPlot(LJ_root, reduction = "umap60", cols = "black")
```

```{r}
LJ_root <- RunUMAP(LJ_root, dims = NULL, features = VariableFeatures(object = LJ_root), reduction.name = "umap_all")
DimPlot(LJ_root, reduction = "umap_all")
```

```{r}
LJ_root <- RunTSNE(LJ_root, dims = 1:60, reduction.name = "tsne60")
DimPlot(LJ_root, reduction = "tsne60")
```

```{r}
FeaturePlot(object = LJ_root, features = 'nFeature_RNA', reduction = 'pca')
FeaturePlot(object = LJ_root, features = 'nFeature_RNA', reduction = 'umap60')
```

```{r}
FeaturePlot(object = LJ_root, features = 'nCount_RNA', reduction = 'pca')
FeaturePlot(object = LJ_root, features = 'nCount_RNA', reduction = 'umap60')
```

```{r}
FeaturePlot(object = LJ_root, features = 'percent.mt', reduction = 'pca')
FeaturePlot(object = LJ_root, features = 'percent.mt', reduction = 'umap60')
```

```{r}
FeaturePlot(object = LJ_root, features = 'percent.clp', reduction = 'pca')
FeaturePlot(object = LJ_root, features = 'percent.clp', reduction = 'umap60')
```

# Clustering

```{r}
LJ_root <- FindNeighbors(LJ_root, dims = 1:60)
LJ_root <- FindClusters(LJ_root, resolution = 0.5)
```

```{r}
# Look at cluster IDs of the first 10 cells
head(Idents(LJ_root), 10)
```

```{r}
DimPlot(LJ_root, reduction = "umap60")
```

```{r}
DimPlot(LJ_root, reduction = "pca")
```

```{r}
DimPlot(LJ_root, reduction = "tsne60")
```

```{r}
DimPlot(LJ_root, reduction = "umap_all")
```

```{r}
DimPlot(LJ_root, reduction = "umap10")
```

## Annotate ploidy

```{r}
#extract matrix of expression values
processed_counts <- as.matrix(LJ_root@assays$RNA$scale.data)
```

```{r}
# Merge the reference expression profile with the normalized expression matrix of our sample  
merge.rownames <- function (x,y){
  dat <- merge(x = x, y = y, by = "row.names")
  rownames(dat) <- dat$Row.names
  dat <- dat[,-1]
  return(dat)
}

load(file="../data/Shahan2022/endo_exp.RD")
ploidy <- Reduce(merge.rownames, list(endo_exp,processed_counts))
```

```{r}
# Prepare customized label name (optional)
ploidy_label=c("2C", "4C", "8C", "16C")
ploidy[,1:10]
```


```{r}
# Calculating the correlation coefficient of each cell to each reference expression profile and annotate the cell as the label that it has the highest correlation coefficient with.  
ploidy_stat <- suppressWarnings(sapply(5:ncol(ploidy),
                                       function(i)
                                         sapply(1:4,
                                                function(j)
                                                  cor.test(ploidy[, i], ploidy[, j], method = "pearson")[c(3, 4)])))

ploidy_cor <- ploidy_stat[seq(2, nrow(ploidy_stat), 2), ]
ploidy_pvalue <- ploidy_stat[seq(1, nrow(ploidy_stat) - 1, 2), ]

ploidy_max <-
  sapply(1:(ncol(ploidy) - 4), function(i)
    max(as.numeric(ploidy_cor[, i])))

ploidy_ident <-
  sapply(1:(ncol(ploidy) - 4), function(i)
    ploidy_label[which(as.numeric(ploidy_cor[, i]) == max(as.numeric(ploidy_cor[, i])))])

ploidy_maxp <-
  sapply(1:(ncol(ploidy) - 4), function(i)
    as.numeric(ploidy_pvalue[, i])[which(as.numeric(ploidy_cor[, i]) == max(as.numeric(ploidy_cor[, i])))])

names(ploidy_max) <- ploidy_ident
```

```{r}
# Store the annotation, correlation coefficient and the p-value in Seurat object
LJ_root@meta.data$ploidy.ID.P <- as.character(ploidy_ident)
LJ_root@meta.data$ploidy.cor.P <- ploidy_max
LJ_root@meta.data$ploidy.pvalue.p <- ploidy_maxp

# In case there is a cell with insufficient info for annotation, label them as unknown
LJ_root@meta.data$ploidy.ID.P[which(LJ_root@meta.data$ploidy.ID.P=="character(0)")]="unknown"
```

```{r fig.height = 16 fig.width = 16}

#options(repr.plot.width=16, repr.plot.height=16)
order <- c("2C","4C","8C","16C","unknown")
palette <- c("#DCEDC8","#42B3D5","#FDEA6F","#CF4F29","#cccccc")

LJ_root$ploidy.ID.P <- factor(LJ_root$ploidy.ID.P, levels=order[sort(match(unique(LJ_root$ploidy.ID.P), order))])
color <- palette

ploidyplot <- DimPlot(LJ_root, group.by="ploidy.ID.P", cols=color, reduction = 'umap60', dims = c(1,2)) + labs(x = "", y = "", title = "Ploidy levels")

pdf(file = "LJ_ploidyplot1.pdf", width = 16, height = 16)
ploidyplot
dev.off()
```

```{r}
FeaturePlot(LJ_root, reduction = "umap60", features = 'AT2G03830')
```

## Cluster annotation heatmap 

```{r}
# Sum of marker genes for every cluster name 
marker_counts <- sapply(unique(cluster_annot_scplant$clusterName), function(cluster) {
  length(unique(cluster_annot_scplant$gene[cluster_annot_scplant$clusterName == cluster]))
})
```


```{r}
# Create a contingency table using xtabs
cluster_matrix <- xtabs(~ cluster + clusterName, data = cluster_annot_merged)

# Normalize table data 
cluster_df <- as.data.frame(cluster_matrix)
marker_counts_df <- as.data.frame(marker_counts) %>%
  rownames_to_column(var = "clusterName")

cluster_marker_counts <- merge(cluster_df, marker_counts_df, by = "clusterName") %>%
  transform(Freq_norm = round(Freq * 10000 / marker_counts))

# Create matrix with the normalized counts 
cluster_matrix_norm <- acast(cluster_marker_counts, cluster ~ clusterName, value.var = "Freq_norm", fun.aggregate = sum)

# Heatmap
pheatmap(cluster_matrix_norm, display_numbers = cluster_matrix)

```
## Dotplot

```{r fig.width = 8 fig.height = 6}
genes <- list(QC = c("AT3G26120", "AT2G03830"), 
              Cortex = c("AT1G62510", "AT1G09750"), 
              Endodermis = c("AT5G57620"), 
              Atrichoblast = c("AT1G79840"), 
              Trichoblast = "AT5G49270", 
              Columella = c("AT1G17400", "AT1G26870"), 
              Phloem = c("AT1G79430"), 
              Xylem = c("AT1G71930"), 
              Stressed = c("AT4G35770", "AT1G15040", "AT2G43510"), 
              Meristematic = c("AT4G37490", "AT4G37490", "AT4G32830", "AT3G05060", "AT2G42740"))

genes <- lapply(genes, function(x){unique(x)})

DotPlot(AT_root, features = genes, group.by = "seurat_clusters", cluster.idents = TRUE) +theme(axis.text.x = element_text(angle = 45, hjust=1), strip.text.x = element_text(angle = 90, hjust = 0))
```

```{r fig.width = 8 fig.height = 6}
genes <- list(Columella = c("AT4G00490", "AT1G23210", "AT5G57640"), 
              Cortex = c("AT1G62510", "AT5G07990", "AT5G55250"), 
              Endodermis = c("AT1G61590", "AT4G02090"), 
              Atrichoblast = c("AT1G79840", "AT2G37260", "AT1G65310"), 
              Trichoblast = c("AT1G33090", "AT3G09330", "AT5G49270"),
              LateralRootCap = c("AT4G37160", "AT3G55930"), 
              QuiescentCenter = c("AT3G26120", "AT1G55200"), 
              Pericycle = c("AT5G26930", "AT1G11330"),
              MitoticActivity = c("AT1G15570"))

genes <- lapply(genes, function(x){unique(x)})

DotPlot(AT_root, features = genes, group.by = "seurat_clusters", cluster.idents = TRUE) +theme(axis.text.x = element_text(angle = 45, hjust=1), strip.text.x = element_text(angle = 90, hjust = 0))
```

```{r}
load(file="/scratch/gent/472/vsc47291/MA1_CompPlantDev/data/Shahan2022/Root_bulk_arabidopsis_curated.RD")
```

```{r}
time <- Reduce(merge.rownames, list(time, processed_counts))
```

```{r}
time_label=c("Elongation", "Maturation", "Meristem")
```

```{r}
# Calculating the correlation coefficient of each cell to each reference expression profile and annotate the cell as the label that it has the highest correlation coefficient with.  
time_stat <- suppressWarnings(
  sapply(4:ncol(time), function(i) sapply(1:3, function(j) cor.test(time[,i],time[,j],method = "pearson")[c(3,4)]))
  )

time_cor <- time_stat[seq(2,nrow(time_stat),2),]
time_pvalue <- time_stat[seq(1,nrow(time_stat)-1,2),]
time_max <- sapply(1:(ncol(time)-3), function(i) max(as.numeric(time_cor[,i])))
time_ident <- sapply(1:(ncol(time)-3), function(i) time_label[which(as.numeric(time_cor[,i])==max(as.numeric(time_cor[,i])))])
time_maxp <- sapply(1:(ncol(time)-3), function(i) as.numeric(time_pvalue[,i])[which(as.numeric(time_cor[,i])==max(as.numeric(time_cor[,i])))])
names(time_max) <- time_ident
```

```{r}
AT_root@meta.data$timezone.ID.P <- as.character(time_ident)
AT_root@meta.data$timezone.cor.P <- time_max
AT_root@meta.data$timezone.pvalue.P <- time_maxp
```

```{r}
timezone <- DimPlot(AT_root, reduction = "umap60", group.by = "timezone.ID.P")+ggtitle("Correlation-based timezone annotation")
```

```{r}
timezone
ploidyplot
```

# Assigning cell type identity to clusters

